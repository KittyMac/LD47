import Flynn
import Foundation
import Socket
import PicaroonFramework
import Pamphlet

class Bot: Actor, Timerable {
    // multiplayer games without people to play with is BOOOORRING.  Need to add
    // some bots in order to make this little world more fun!

    // A bot in this game should act like any other player; meaning they should not gain
    // any special priviledges (such as advanced sight). They should interact using the
    // same APIs that players do.

    private weak var game: Game?
    private var playerName: String
    private var rng: Randomable
    private let visRange = 65

    deinit {
        //print("deinit - bot")
    }

    init(_ game: Game, _ seed: UInt64) {
        self.game = game
        self.playerName = ""
        self.rng = Xoroshiro256StarStar(seed)
        super.init()

        self.unsafePriority = -1

        self.playerName = "BOT"

        // stagger bot start times to avoid large spikes in activity
        Flynn.Timer(timeInterval: Double(rng.get(min: 1.0, max: 10.0)), repeats: false, self, ["DELAY"])
    }

    private func _beTimerFired(_ timer: Flynn.Timer, _ args: TimerArgs) {
        guard let game = game else { return }

        if args[0] as? String == "DELAY" {
            Flynn.Timer(timeInterval: kTransitTime + 0.4, repeats: true, self, ["UPDATE"])
        }

        if args[0] as? String == "UPDATE" {
            game.beGetBoardUpdate(self.unsafeUUID, self.visRange, self.visRange, self) { (board) in
                if let board = board {
                    if let player = board.player {
                        self.performTurn(player, board)
                    } else {
                        self.joinGame(board)
                    }
                }
            }
        }

    }

    private func getNodeById(_ nodeIdx: Int, _ board: BoardUpdate) -> Node? {
        for node in board.nodes where node.id == nodeIdx {
            return node
        }
        return nil
    }

    private func joinGame(_ board: BoardUpdate) {
        guard let game = game else { return }

        game.beAddPlayer(unsafeUUID, rng.get(min: 0, max: 3), playerName, true, self) { (_) in }
    }

    private func performTurn(_ player: Player, _ board: BoardUpdate) {
        if rng.maybe(0.2) {
            doNothing(player, board)
        } else if rng.maybe(0.5) {
            moveTowardsAnotherPlayer(player, board)
        } else if rng.maybe(0.5) {
            moveTowardsTheExit(player, board)
        } else {
            moveRandom(player, board)
        }
    }

    private func moveRandom(_ player: Player, _ board: BoardUpdate) {
        guard let game = game else { return }

        if let playerNode = getNodeById(player.nodeIdx, board) {
            let nextNodeIdx = rng.get(playerNode.c)
            game.beMovePlayer(unsafeUUID, nextNodeIdx, visRange, visRange, self) { (_) in }
        }
    }

    private func moveTowardsAnotherPlayer(_ player: Player, _ board: BoardUpdate) {
        guard let game = game else { return }

        if let playerNode = getNodeById(player.nodeIdx, board) {

            // find the "closest" player who is not of my team,
            // not me, and not immune
            var otherPlayersByNodeIdx: [Int: Player] = [:]

            for other in board.players where
                other.id != player.id &&
                other.teamId != player.teamId &&
                other.immune == false {
                otherPlayersByNodeIdx[other.nodeIdx] = other
            }

            // check my neighbors; if a player is there go after them
            for goToNodeIdx in playerNode.c where otherPlayersByNodeIdx[goToNodeIdx] != nil {
                game.beMovePlayer(unsafeUUID, goToNodeIdx, visRange, visRange, self) { (_) in }
                return
            }

            // otherwise, move randomly
            moveRandom(player, board)
        }
    }

    private func moveTowardsTheExit(_ player: Player, _ board: BoardUpdate) {
        guard let game = game else { return }

        if let playerNode = getNodeById(player.nodeIdx, board) {

            var myDistance = playerNode.d
            var goToNodeIdx = playerNode.id
            for otherIdx in playerNode.c {
                if let otherNode = getNodeById(otherIdx, board) {
                    if otherNode.d < myDistance {
                        myDistance = otherNode.d
                        goToNodeIdx = otherNode.id
                    }
                }
            }

            // if we didn't find any to move to, just choose a random one
            if goToNodeIdx == player.nodeIdx {
                goToNodeIdx = rng.get(playerNode.c)
            }

            game.beMovePlayer(unsafeUUID, goToNodeIdx, visRange, visRange, self) { (_) in }
        }
    }

    private func doNothing(_ player: Player, _ board: BoardUpdate) {

    }

}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension Bot {

    @discardableResult
    public func beTimerFired(_ timer: Flynn.Timer,
                             _ args: TimerArgs) -> Self {
        unsafeSend { self._beTimerFired(timer, args) }
        return self
    }

}
